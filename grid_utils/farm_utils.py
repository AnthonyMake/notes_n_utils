#!/slowfs/dcopt105/vasquez/cnda/Conda/bin/python
 
import pickle, os, re
import datetime, subprocess
import pandas as pd
from pandas import ExcelWriter
import xml.etree.ElementTree as et
import datetime

import pprint
pp = pprint.PrettyPrinter(indent = 1, depth= 3)

# global paths to qsta utilities
# just in case
#qstat  = '/remote/sge3/default/bin/lx-amd64/qstat'
#qalter = '/remote/sge3/default/bin/lx-amd64/qalter'
# available_info = ['JB_job_number', 'JAT_prio', 'JAT_ntix', 'JB_nurg', 'JB_urg', 'JB_rrcontr', 'JB_wtcontr', 'JB_dlcontr', 'JB_name', 'JB_owner', 'JB_project', 'JB_department', 'state', 'JB_submission_time', 'tickets', 'JB_override_tickets', 'JB_jobshare', 'otickets', 'ftickets', 'stickets', 'JAT_share', 'queue_name', 'jclass_name', 'slots']


def get_qstat(user, farm):
    farms = {
        'gala' : 'source /remote/sge/default/galapagos/common/settings.csh; set qstat_real = qstat',
        'snps' : 'source /remote/sge/default/snps/common/settings.csh; set qstat_real = qstat',
    }

    cmd = '%s; qstat -u %s -r -xml'%(farms[farm],user)
    cmd_obj = subprocess.run(cmd, executable= '/bin/csh',shell = True,stdout=subprocess.PIPE)    
    cmd_ret = cmd_obj.stdout.decode("utf-8")
    return cmd_ret

def qstat_from_xml(xml):

    # parse the xml file from a synopsys grid like
    # from a textfile generated by
    # qstat -u <some_user> -xml > some_xml_file.xml
    # 
    # returns a dict in the form:
    # {running : [{jb1_info1: ... , jb1_info2: ...,},{jb2_info1:..., jb2_info2:...}...],
    #  pending : [{jba_info1: ... , jba_info2: ...,},{jbb_info1:..., jbb_info2:...}...],}            
    # 
    # -vasquez- 

    if type(xml) == str:
        all_jobs = et.fromstring(xml)
    else:
        # parse the xml file
        tree = et.parse(xml)
        all_jobs = tree.getroot()

    # The xml output structure for qstat has two queues
    # one with all running jobs, and another one with
    # the ending ones,
    # 
    # queue_info
    #     job_list state: running
    #         job_number 
    #         prior
    #         ...
    #     job_list state: running
    #         job_number 
    #         prior
    #         ...
    #     ...
    # job_info
    #     job_list state: pending
    #         job_number
    #         prior
    #         ...
    #     job_list state: pending
    #         ...
    #     ...
    # 
    # queue_info: contains only running jobs
    # job_info: contains only pending jobs

    qstat_dict = {}

    for queue in all_jobs:

        if queue.tag == 'queue_info':
            current_queue = 'running'
        elif queue.tag == 'job_info':
            current_queue = 'pending'
        else:
            print('Warning: we are not prepared for fields like: ' + str(queue.tag) + ' in the top level') 

        if current_queue not in qstat_dict:        
            qstat_dict[current_queue] = []

        for job_info in queue:
            
            # the job info will always be running for queue_info
            # and pending for job_info, ...i hope so 
            
            job_info_dict = {}

            for field in job_info:

                tag = field.tag    
                value = field.text
                attrib = field.attrib

                job_info_dict['%s/%s'%(tag,attrib)] = value

            
            qstat_dict[current_queue].append(job_info_dict)
                
    # pp.pprint(qstat_dict)
    return qstat_dict

def qstat_to_df(qstat_dict, status, excluded, users, machines, usrs):

    print('making dataframe for %s'%status)

    qstat_df = pd.DataFrame()

    # for job in qstat_dict['running']:

    #     job_serie = pd.Series()
        
    #     for data in job.keys():
    #         job_serie[data] = job[data]

    #     qstat_df[job_serie['JB_job_number']] = job_serie

    index = 1
    #machines = {}
    #usrs = {}

    cel_names = []
    machines[status] = {}
    usrs[status] = {}

    for job in qstat_dict[status]:
        job_serie = pd.Series()
        
        for data in job.keys():

            cel_name = ''
            # lets filter tricky nested names like this
            # hard_request/{'name': 'hconfig', 'resource_contribution': '0.000000'}
            ptrn_hard_req = r'hard_request\/\{\'name\'\:\s\'(.+)\',.+'

            # JB_job_number/{}
            ptrn_key = r'(.+)\/\{\}'

            m_hard_req = re.match(ptrn_hard_req, data)
            m_key      = re.match(ptrn_key, data)

            if m_hard_req: cel_name = m_hard_req.group(1)
            elif m_key: cel_name = m_key.group(1)
            else: cel_name = data


            if cel_name not in excluded:
                job_serie[cel_name] = job[data]

                # accounting
                # machines[status]['no_rt'] = []
                if cel_name == 'hconfig':
                    machine_name = job[data] if len(job[data])>3 else 'no_rt'
                    
                    if machine_name not in machines[status]:
                        machines[status][machine_name] =  1
                    else:
                        machines[status][machine_name] += 1 

                if cel_name == 'JB_owner':
                    user_name = job[data]
                    if user_name not in usrs[status]:
                        usrs[status][user_name] = 1
                    else:
                        usrs[status][user_name] += 1
                    
        qstat_df[index] = job_serie
        index += 1

    return qstat_df, machines, usrs

def sum_numbers(qstat_dict):
    numbers = {}
    numbers['running'] = {'total': len(qstat_dict['running'])}
    numbers['pending'] = {'total': len(qstat_dict['pending'])}

    numbers['running']['reg'] = 0
    numbers['running']['ext'] = 0

    numbers['pending']['reg'] = 0
    numbers['pending']['ext'] = 0

    for queue,jb_list in qstat_dict.items():

        for jb in jb_list: 
            f_name = jb['JB_name/{}'].split('%')[0]
            # print(f_name)
            
            if 'ex' in f_name:
                numbers[queue]['ext'] += 1
            else:
                numbers[queue]['reg'] += 1
                
    numbers['pend_run_ratio'] = numbers['pending']['total'] / numbers['running']['total']
    numbers['pend_run_ext_ratio'] = numbers['pending']['ext'] / numbers['running']['ext']
    numbers['pend_run_reg_ratio'] = numbers['pending']['reg'] / numbers['running']['reg']
    numbers['ext_reg_pend_ratio'] = numbers['pending']['ext'] / numbers['pending']['reg']
    numbers['ext_reg_run_ratio'] = numbers['running']['ext'] / numbers['running']['reg']

    return numbers
