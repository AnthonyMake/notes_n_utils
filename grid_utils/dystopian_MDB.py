#!/slowfs/dcopt105/vasquez/cnda/Conda/bin/python
 
import pickle, os, re
import datetime, subprocess
import pandas as pd
from pandas import ExcelWriter
import xml.etree.ElementTree as et
import datetime
from balancer import *
from datetime import datetime
# Mongo db
from pymongo import MongoClient


import pprint
pp = pprint.PrettyPrinter(indent = 1, depth= 3)

# global paths to qsta utilities
# just in case
qstat  = '/remote/sge3/default/bin/lx-amd64/qstat'
qalter = '/remote/sge3/default/bin/lx-amd64/qalter'
# available_info = ['JB_job_number', 'JAT_prio', 'JAT_ntix', 'JB_nurg', 'JB_urg', 'JB_rrcontr', 'JB_wtcontr', 'JB_dlcontr', 'JB_name', 'JB_owner', 'JB_project', 'JB_department', 'state', 'JB_submission_time', 'tickets', 'JB_override_tickets', 'JB_jobshare', 'otickets', 'ftickets', 'stickets', 'JAT_share', 'queue_name', 'jclass_name', 'slots']


def get_qstat(user, farm):
    farms = {
        'gala' : 'source /remote/sge/default/galapagos/common/settings.csh; set qstat_real = qstat',
        'snps' : 'source /remote/sge/default/snps/common/settings.csh; set qstat_real = qstat',
    }

    cmd = '%s; qstat -u %s -r -xml'%(farms[farm],user)
    cmd_obj = subprocess.run(cmd, executable= '/bin/csh',shell = True,stdout=subprocess.PIPE)    
    cmd_ret = cmd_obj.stdout.decode("utf-8")
    return cmd_ret

def qstat_from_xml(xml):

    # parse the xml file from a synopsys grid like
    # from a textfile generated by
    # qstat -u <some_user> -xml > some_xml_file.xml
    # 
    # returns a dict in the form:
    # {running : [{jb1_info1: ... , jb1_info2: ...,},{jb2_info1:..., jb2_info2:...}...],
    #  pending : [{jba_info1: ... , jba_info2: ...,},{jbb_info1:..., jbb_info2:...}...],}            
    # 
    # -vasquez- 

    if type(xml) == str:
        all_jobs = et.fromstring(xml)
    else:
        # parse the xml file
        tree = et.parse(xml)
        all_jobs = tree.getroot()

    # The xml output structure for qstat has two queues
    # one with all running jobs, and another one with
    # the ending ones,
    # 
    # queue_info
    #     job_list state: running
    #         job_number 
    #         prior
    #         ...
    #     job_list state: running
    #         job_number 
    #         prior
    #         ...
    #     ...
    # job_info
    #     job_list state: pending
    #         job_number
    #         prior
    #         ...
    #     job_list state: pending
    #         ...
    #     ...
    # 
    # queue_info: contains only running jobs
    # job_info: contains only pending jobs

    qstat_dict = {}

    for queue in all_jobs:

        if queue.tag == 'queue_info':
            current_queue = 'running'
        elif queue.tag == 'job_info':
            current_queue = 'pending'
        else:
            print('Warning: we are not prepared for fields like: ' + str(queue.tag) + ' in the top level') 

        if current_queue not in qstat_dict:        
            qstat_dict[current_queue] = []

        for job_info in queue:
            
            # the job info will always be running for queue_info
            # and pending for job_info, ...i hope so 
            
            job_info_dict = {}

            for field in job_info:

                tag = field.tag    
                value = field.text
                attrib = field.attrib

                job_info_dict['%s/%s'%(tag,attrib)] = value

            
            qstat_dict[current_queue].append(job_info_dict)
                
    # pp.pprint(qstat_dict)
    return qstat_dict
machines = {}
usrs = {}
def qstat_to_df(qstat_dict, status, excluded, users):

    print('making dataframe for %s'%status)

    qstat_df = pd.DataFrame()

    # for job in qstat_dict['running']:

    #     job_serie = pd.Series()
        
    #     for data in job.keys():
    #         job_serie[data] = job[data]

    #     qstat_df[job_serie['JB_job_number']] = job_serie

    index = 1
    machines = {}
    usrs = {}

    cel_names = []
    machines[status] = {}
    usrs[status] = {}

    for job in qstat_dict[status]:
        job_serie = pd.Series()
        
        for data in job.keys():

            cel_name = ''
            # lets filter tricky nested names like this
            # hard_request/{'name': 'hconfig', 'resource_contribution': '0.000000'}
            ptrn_hard_req = r'hard_request\/\{\'name\'\:\s\'(.+)\',.+'

            # JB_job_number/{}
            ptrn_key = r'(.+)\/\{\}'

            m_hard_req = re.match(ptrn_hard_req, data)
            m_key      = re.match(ptrn_key, data)

            if m_hard_req: cel_name = m_hard_req.group(1)
            elif m_key: cel_name = m_key.group(1)
            else: cel_name = data


            if cel_name not in excluded:
                job_serie[cel_name] = job[data]

                # accounting
                # machines[status]['no_rt'] = []
                if cel_name == 'hconfig':
                    machine_name = job[data] if len(job[data])>3 else 'no_rt'
                    
                    if machine_name not in machines[status]:
                        machines[status][machine_name] =  1
                    else:
                        machines[status][machine_name] += 1 

                if cel_name == 'JB_owner':
                    user_name = job[data]
                    if user_name not in usrs[status]:
                        usrs[status][user_name] = 1
                    else:
                        usrs[status][user_name] += 1
                    
        qstat_df[index] = job_serie
        index += 1

    return qstat_df


def sum_by(qstat_dict):

    excluded = 'full_job_name arch queue_name jclass_name health binding'.split()
    index = 1
    machines = {}
    usrs = {}

    numbers = {}
    numbers['running'] = {'total': len(qstat_dict['running'])}
    numbers['pending'] = {'total': len(qstat_dict['pending'])}

    numbers['running']['reg'] = 0
    numbers['running']['ext'] = 0

    numbers['pending']['reg'] = 0
    numbers['pending']['ext'] = 0

    cel_names = []


    for status in qstat_dict:
        # qstat_dict has two queues, running and pending
        for job in qstat_dict[status]:
            for data in job.keys():
                cel_name = ''
                # lets filter tricky nested names like this
                # hard_request/{'name': 'hconfig', 'resource_contribution': '0.000000'}
                ptrn_hard_req = r'hard_request\/\{\'name\'\:\s\'(.+)\',.+'

                # JB_job_number/{}
                ptrn_key = r'(.+)\/\{\}'

                m_hard_req = re.match(ptrn_hard_req, data)
                m_key      = re.match(ptrn_key, data)

                if m_hard_req: cel_name = m_hard_req.group(1)
                elif m_key: cel_name = m_key.group(1)
                else: cel_name = data

                if cel_name not in excluded:
    
                    # accounting
                    # machines[status]['no_rt'] = []
                    if cel_name == 'hconfig':
                        machine_name = job[data] if len(job[data])>3 else 'no_rt'
                        
                        if machine_name not in machines:
                            machines[machine_name]= {}
                            machines[machine_name][status] =  1
                        else:
                            if status not in machines[machine_name]:
                                machines[machine_name][status] = 0
                            machines[machine_name][status] += 1 

                    if cel_name == 'JB_owner':
                        user_name = job[data]
                        if user_name not in usrs:
                            usrs[user_name] = {}
                            usrs[user_name][status] = 1
                        else:
                            if status not in usrs[user_name]: 
                                usrs[user_name][status] = 0
                            usrs[user_name][status] += 1

                    if cel_name == 'JB_name':
                        name = job[data]
                        f_name = name.split('%')[0] if '%' in name else name

                        if 'ex' in f_name:
                            numbers[status]['ext'] += 1
                        else:
                            numbers[status]['reg'] += 1

    numbers['pend_run_ratio'] = numbers['pending']['total'] / numbers['running']['total'] if numbers['running']['total'] else None
    numbers['pend_run_ext_ratio'] = numbers['pending']['ext'] / numbers['running']['ext'] if numbers['running']['ext'] else None
    numbers['pend_run_reg_ratio'] = numbers['pending']['reg'] / numbers['running']['reg'] if numbers['running']['reg'] else None
    numbers['ext_reg_pend_ratio'] = numbers['pending']['ext'] / numbers['pending']['reg'] if numbers['pending']['reg'] else None
    numbers['ext_reg_run_ratio'] = numbers['running']['ext'] / numbers['running']['reg'] if numbers['running']['reg'] else None
                        
    #pp.pprint(usrs)
    #pp.pprint(machines)
    #pp.pprint(numbers)
    return usrs, machines, numbers


####################################################################

farm = 'gala'
le_stamp = datetime.now()
# users = 'sruti castelan chunwang dcexp dcntqor1 dcntqor2 dcntqor3 dcntqor4 dcntqor5 dcntqor6 dcntqor7 dcnwmgr dcqor dcrtqor dcultra ecklk optzmgr rmorale estebanv vasquez alvarez orellana riquelme alvaro claudioa synint omars alvaroq yizhang andresp'

users = 'dcntqor6 dcntqor7 rmorale vasquez omars andresp alvear matiasj dcqor xgcpu'
#users += 'estebanv alvarez riquelme orellana rodr mramire '
# redundant or useless data

# users = 'vasquez'
excluded        = 'full_job_name arch queue_name jclass_name health binding'.split()

xml = get_qstat(users,'gala')
qstat_dict = qstat_from_xml(xml)

user_sum, machine_sum, type_total_sum = sum_by(qstat_dict)

# pp.pprint(qstat_dict)
####################################3
# the function def could be start here

# # Mongo Stuff
client    = MongoClient('pvdc002', 27017)
dc_db     = client.dcnxt_data
farm_data = dc_db['farm']

#(2021,03,23,22,07,54,160501)
#obj_time = datetime(2021, 3, 23, 22, 13, 3, 479000)
#farm_dict = farm_data.find({})
# farm_data.delete_one({'timestamp':'20210322_0911'})
# exit()
#pp.pprint(farm_dict)

# exit()
#index = []
#for coll in farm_dict:
#      pp.pprint(coll['timestamp'])
      
#      index.append(coll['timestamp'])
#index.sort()

#print(index[-1])

#exit()

save_headers = '''
job_number
job_state
job_name
flow
design
priority
jobshare
owner
submission_time
start_time
script_file
version
project
exec_host_list
usage
hard
cwd
submit_cmd
'''.strip().split('\n')

save_headers_lite = '''
job_number
job_state
job_name
flow
design
priority
owner
submission_time
start_time
script_file
version
project
exec_host_list
usage
hard
cwd
submit_cmd
'''.strip().split('\n')



csv = ','.join(save_headers)
# pp.pprint(csv)
csv += '\n'


P = len(qstat_dict['pending'])
R = len(qstat_dict['running'])
T = P + R


print('T: %s   R: %s   P: %s'%(T,R,P))

snapshot = {
    'farm': farm,
    'timestamp': le_stamp, 
    'users' : users.split(),
    'jobs_data': [],
    'users_summary': user_sum,
    'hconfig_summary' : machine_sum,
    'extra_reg_summary': type_total_sum
}

print(le_stamp)

print('Gathering job status...')

full_state = False

for name, Q in qstat_dict.items():
    for J in Q:
        job_num = J['JB_job_number/{}']

        pp.pprint(J)
        
        if full_state:
            full_jb_info = get_full_stat(farm,job_num)
            if not full_jb_info: continue
        # pp.pprint(full_jb_info)

        jb_dict = {}

        csv_line = []
        for h in save_headers:
            if h == 'priority':
                csv_line.append(J['JAT_prio/{}'])
                jb_dict[h] = J['JAT_prio/{}']

            elif h == 'job_state':
                csv_line.append(J['state/{}'])
                jb_dict[h] = J['state/{}']

            if not full_state:
                continue

            elif h in 'submit_cmd usage hard'.split() and h in full_jb_info:
                csv_line.append('"%s"'%full_jb_info[h])
                jb_dict[h] = full_jb_info[h]

            elif h == 'job_name':
                if '%' in full_jb_info[h]:
                    jb_dict['flow']   = full_jb_info[h].split('%')[0]
                    jb_dict['design'] = full_jb_info[h].split('%')[1]
                
                else:
                    jb_dict['flow']   = '--'
                    jb_dict['design'] = '--'

            elif h in 'design flow'.split():
                pass

            else:
                try:
                    csv_line.append(full_jb_info[h])
                    jb_dict[h] = full_jb_info[h]
                except:
                    csv_line.append('--')
                    jb_dict[h] = '--'
        
        snapshot['jobs_data'].append(jb_dict.copy())
        csv += ','.join(csv_line)
        csv += '\n'

print('submitting data to DB...')
farm_data.insert_one(snapshot)

exit()
print('writting csv...')
csv_file = open('snapshots/qstat_%s.csv'%le_stamp, 'w')
csv_file.write(csv)
csv_file.close()

print('done.')

# exit()

'''
numbers = sum_numbers(qstat_dict)
pp.pprint(numbers)



qstat_df_running  = qstat_to_df(qstat_dict, 'running', excluded, users)
qstat_df_pending  = qstat_to_df(qstat_dict, 'pending', excluded, users)

pp.pprint(machines)
pp.pprint(usrs)

qstat_df_running  = qstat_df_running.T
qstat_df_pending  = qstat_df_pending.T


# print('describing...')
# df_running_stats = qstat_df_running.describe(include= 'all')
# df_pending_stats = qstat_df_pending.describe(include= 'all')

qstat_df_running.to_excel(writer, sheet_name= 'r_gala')
qstat_df_pending.to_excel(writer, sheet_name= 'qw_gala')

###############
xml = get_qstat(users,'snps')
qstat_dict = qstat_from_xml(xml)
qstat_df_running  = qstat_to_df(qstat_dict, 'running', excluded, users)
qstat_df_pending  = qstat_to_df(qstat_dict, 'pending', excluded, users)

pp.pprint(machines)
pp.pprint(usrs)

qstat_df_running  = qstat_df_running.T
qstat_df_pending  = qstat_df_pending.T


# print('describing...')
# df_running_stats = qstat_df_running.describe(include= 'all')
# df_pending_stats = qstat_df_pending.describe(include= 'all')

qstat_df_running.to_excel(writer, sheet_name= 'r_snps')
qstat_df_pending.to_excel(writer, sheet_name= 'qw_snps')

writer.save()
print('done.')
'''