#!/slowfs/dcopt105/vasquez/cnda/Conda/bin/python
 
import pickle, os, re
import datetime, subprocess
import pandas as pd
from pandas import ExcelWriter
import xml.etree.ElementTree as et
import datetime
from balancer import *
from datetime import datetime

import pprint
pp = pprint.PrettyPrinter(indent = 1, depth= 3)

# global paths to qsta utilities
# just in case
qstat  = '/remote/sge3/default/bin/lx-amd64/qstat'
qalter = '/remote/sge3/default/bin/lx-amd64/qalter'
# available_info = ['JB_job_number', 'JAT_prio', 'JAT_ntix', 'JB_nurg', 'JB_urg', 'JB_rrcontr', 'JB_wtcontr', 'JB_dlcontr', 'JB_name', 'JB_owner', 'JB_project', 'JB_department', 'state', 'JB_submission_time', 'tickets', 'JB_override_tickets', 'JB_jobshare', 'otickets', 'ftickets', 'stickets', 'JAT_share', 'queue_name', 'jclass_name', 'slots']


def get_qstat(user, farm):
    farms = {
        'gala' : 'source /remote/sge/default/galapagos/common/settings.csh; set qstat_real = qstat',
        'snps' : 'source /remote/sge/default/snps/common/settings.csh; set qstat_real = qstat',
    }

    cmd = '%s; qstat -u %s -r -xml'%(farms[farm],user)
    cmd_obj = subprocess.run(cmd, executable= '/bin/csh',shell = True,stdout=subprocess.PIPE)    
    cmd_ret = cmd_obj.stdout.decode("utf-8")
    return cmd_ret

def qstat_from_xml(xml):

    # parse the xml file from a synopsys grid like
    # from a textfile generated by
    # qstat -u <some_user> -xml > some_xml_file.xml
    # 
    # returns a dict in the form:
    # {running : [{jb1_info1: ... , jb1_info2: ...,},{jb2_info1:..., jb2_info2:...}...],
    #  pending : [{jba_info1: ... , jba_info2: ...,},{jbb_info1:..., jbb_info2:...}...],}            
    # 
    # -vasquez- 

    if type(xml) == str:
        all_jobs = et.fromstring(xml)
    else:
        # parse the xml file
        tree = et.parse(xml)
        all_jobs = tree.getroot()

    # The xml output structure for qstat has two queues
    # one with all running jobs, and another one with
    # the ending ones,
    # 
    # queue_info
    #     job_list state: running
    #         job_number 
    #         prior
    #         ...
    #     job_list state: running
    #         job_number 
    #         prior
    #         ...
    #     ...
    # job_info
    #     job_list state: pending
    #         job_number
    #         prior
    #         ...
    #     job_list state: pending
    #         ...
    #     ...
    # 
    # queue_info: contains only running jobs
    # job_info: contains only pending jobs

    qstat_dict = {}

    for queue in all_jobs:

        if queue.tag == 'queue_info':
            current_queue = 'running'
        elif queue.tag == 'job_info':
            current_queue = 'pending'
        else:
            print('Warning: we are not prepared for fields like: ' + str(queue.tag) + ' in the top level') 

        if current_queue not in qstat_dict:        
            qstat_dict[current_queue] = []

        for job_info in queue:
            
            # the job info will always be running for queue_info
            # and pending for job_info, ...i hope so 
            
            job_info_dict = {}

            for field in job_info:

                tag = field.tag    
                value = field.text
                attrib = field.attrib

                job_info_dict['%s/%s'%(tag,attrib)] = value

            
            qstat_dict[current_queue].append(job_info_dict)
                
    # pp.pprint(qstat_dict)
    return qstat_dict
machines = {}
usrs = {}
def qstat_to_df(qstat_dict, status, excluded, users):

    print('making dataframe for %s'%status)

    qstat_df = pd.DataFrame()

    # for job in qstat_dict['running']:

    #     job_serie = pd.Series()
        
    #     for data in job.keys():
    #         job_serie[data] = job[data]

    #     qstat_df[job_serie['JB_job_number']] = job_serie

    index = 1
    machines = {}
    usrs = {}

    cel_names = []
    machines[status] = {}
    usrs[status] = {}

    for job in qstat_dict[status]:
        job_serie = pd.Series()
        
        for data in job.keys():

            cel_name = ''
            # lets filter tricky nested names like this
            # hard_request/{'name': 'hconfig', 'resource_contribution': '0.000000'}
            ptrn_hard_req = r'hard_request\/\{\'name\'\:\s\'(.+)\',.+'

            # JB_job_number/{}
            ptrn_key = r'(.+)\/\{\}'

            m_hard_req = re.match(ptrn_hard_req, data)
            m_key      = re.match(ptrn_key, data)

            if m_hard_req: cel_name = m_hard_req.group(1)
            elif m_key: cel_name = m_key.group(1)
            else: cel_name = data


            if cel_name not in excluded:
                job_serie[cel_name] = job[data]

                # accounting
                # machines[status]['no_rt'] = []
                if cel_name == 'hconfig':
                    machine_name = job[data] if len(job[data])>3 else 'no_rt'
                    
                    if machine_name not in machines[status]:
                        machines[status][machine_name] =  1
                    else:
                        machines[status][machine_name] += 1 

                if cel_name == 'JB_owner':
                    user_name = job[data]
                    if user_name not in usrs[status]:
                        usrs[status][user_name] = 1
                    else:
                        usrs[status][user_name] += 1
                    
        qstat_df[index] = job_serie
        index += 1

    return qstat_df


def sum_numbers(qstat_dict):
    numbers = {}
    numbers['running'] = {'total': len(qstat_dict['running'])}
    numbers['pending'] = {'total': len(qstat_dict['pending'])}

    numbers['running']['reg'] = 0
    numbers['running']['ext'] = 0

    numbers['pending']['reg'] = 0
    numbers['pending']['ext'] = 0

    for queue,jb_list in qstat_dict.items():

        for jb in jb_list: 
            f_name = jb['JB_name/{}'].split('%')[0]
            #print(f_name)
            
            if 'ex' in f_name:
                numbers[queue]['ext'] += 1
            else:
                numbers[queue]['reg'] += 1
                
    numbers['pend_run_ratio'] = numbers['pending']['total'] / numbers['running']['total']
    numbers['pend_run_ext_ratio'] = numbers['pending']['ext'] / numbers['running']['ext']
    numbers['pend_run_reg_ratio'] = numbers['pending']['reg'] / numbers['running']['reg']
    numbers['ext_reg_pend_ratio'] = numbers['pending']['ext'] / numbers['pending']['reg']
    numbers['ext_reg_run_ratio'] = numbers['running']['ext'] / numbers['running']['reg']

    return numbers

farm = 'gala'
le_stamp = datetime.now().strftime("%Y%m%d_%H%M")
# users = 'sruti castelan chunwang dcexp dcntqor1 dcntqor2 dcntqor3 dcntqor4 dcntqor5 dcntqor6 dcntqor7 dcnwmgr dcqor dcrtqor dcultra ecklk optzmgr rmorale estebanv vasquez alvarez orellana riquelme alvaro claudioa synint omars alvaroq yizhang andresp'

users = 'dcntqor6 dcntqor7 rmorale vasquez omars andresp alvear matiasj dcqor xgcpu dcexp '
users += 'estebanv alvarez riquelme orellana rodr mramire '
# redundant or useless data

# users = 'rmorale'
excluded        = 'full_job_name arch queue_name jclass_name health binding'.split()

xml = get_qstat(users,'gala')
qstat_dict = qstat_from_xml(xml)

# pp.pprint(qstat_dict)

save_headers = '''
job_number
job_state
job_name
priority
jobshare
owner
submission_time
start_time
script_file
version
project
exec_host_list
usage
hard
cwd
submit_cmd
'''.strip().split('\n')

csv = ','.join(save_headers)
# pp.pprint(csv)
csv += '\n'


P = len(qstat_dict['pending'])
R = len(qstat_dict['running'])
T = P + R


print('T: %s   R: %s   P: %s'%(T,R,P))

for name, Q in qstat_dict.items():
    for J in Q:
        # pp.pprint(J)
        job_num = J['JB_job_number/{}']
        full_jb_info = get_full_stat(farm,job_num)



        if not full_jb_info: continue
        # pp.pprint(full_jb_info)

        csv_line = []
        for h in save_headers:
            if h == 'priority':
                csv_line.append(J['JAT_prio/{}'])
            elif h == 'job_state':
                csv_line.append(J['state/{}'])
            elif h in 'submit_cmd usage hard'.split() and h in full_jb_info:
                csv_line.append('"%s"'%full_jb_info[h])
            else:
                try:
                    csv_line.append(full_jb_info[h])
                except:
                    csv_line.append('--')
        
        csv += ','.join(csv_line)
        csv += '\n'

csv_file = open('snapshots/qstat_%s.csv'%le_stamp, 'w')
csv_file.write(csv)
csv_file.close()

# exit()

'''
numbers = sum_numbers(qstat_dict)
pp.pprint(numbers)



qstat_df_running  = qstat_to_df(qstat_dict, 'running', excluded, users)
qstat_df_pending  = qstat_to_df(qstat_dict, 'pending', excluded, users)

pp.pprint(machines)
pp.pprint(usrs)

qstat_df_running  = qstat_df_running.T
qstat_df_pending  = qstat_df_pending.T


# print('describing...')
# df_running_stats = qstat_df_running.describe(include= 'all')
# df_pending_stats = qstat_df_pending.describe(include= 'all')

qstat_df_running.to_excel(writer, sheet_name= 'r_gala')
qstat_df_pending.to_excel(writer, sheet_name= 'qw_gala')

###############
xml = get_qstat(users,'snps')
qstat_dict = qstat_from_xml(xml)
qstat_df_running  = qstat_to_df(qstat_dict, 'running', excluded, users)
qstat_df_pending  = qstat_to_df(qstat_dict, 'pending', excluded, users)

pp.pprint(machines)
pp.pprint(usrs)

qstat_df_running  = qstat_df_running.T
qstat_df_pending  = qstat_df_pending.T


# print('describing...')
# df_running_stats = qstat_df_running.describe(include= 'all')
# df_pending_stats = qstat_df_pending.describe(include= 'all')

qstat_df_running.to_excel(writer, sheet_name= 'r_snps')
qstat_df_pending.to_excel(writer, sheet_name= 'qw_snps')

writer.save()
print('done.')
'''